{"version":3,"sources":["/Users/thejameskyle/git/marionette/backbone-metal/src/backbone-metal.js"],"names":[],"mappings":"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","file":"backbone-metal.min.js","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['backbone', 'underscore'], factory);\n  } else if (typeof exports !== 'undefined') {\n    module.exports = factory(require('backbone'), require('underscore'));\n  } else {\n    factory(root.Backbone, root._);\n  }\n})(this, function(Backbone, _) {\n  'use strict';\n  \n  var _slice = Array.prototype.slice;\n\n  /**\n   * @module Metal\n   */\n  var Metal = {};\n  \n  /**\n   * Wraps the passed method so that `this._super` will point to the superMethod\n   * when the method is invoked.\n   *\n   * @private\n   * @method wrap\n   * @param {Function} method - The method to call.\n   * @param {Function} superMethod - The super method.\n   * @return {Function} - wrapped function.\n   */\n  function wrap(method, superMethod) {\n    return function() {\n      var prevSuper = this._super;\n      this._super = superMethod;\n      var ret = method.apply(this, arguments);\n      this._super = prevSuper;\n      return ret;\n    };\n  }\n  \n  /**\n   * A reference to safe regex for checking if a function calls `_super`.\n   *\n   * @private\n   * @const {RegExp}\n   */\n  var superTest = (/xyz/.test(function(){return 'xyz';})) ? /\\b_super\\b/ : /.*/;\n  \n  /**\n   * Assigns properties of source object to destination object, wrapping methods\n   * that call their super method.\n   *\n   * @private\n   * @method wrapAll\n   * @param {Object} dest - The destination object.\n   * @param {Object} source - The source object.\n   */\n  function wrapAll(dest, source) {\n    _.forEach(source, function(method, name) {\n      // If we didn't find the original value in the original object\n      var superMethod = dest[name];\n  \n      // Test if new method calls `_super`\n      var hasSuper = superTest.test(method);\n  \n      // Only wrap the new method if the original method was a function and the\n      // new method calls `_super`.\n      if (hasSuper && _.isFunction(method) && _.isFunction(superMethod)) {\n        dest[name] = wrap(method, superMethod);\n  \n      // Otherwise just add the new method or property to the object.\n      } else {\n        dest[name] = method;\n      }\n    });\n  }\n  \n  /**\n   * Creates a new Class.\n   *\n   * ```js\n   * var MyClass = Class.extend({\n   *   initialize() {\n   *     console.log('Created!');\n   *   }\n   * });\n   *\n   * new MyClass();\n   * // >> Created!\n   * ```\n   *\n   * @public\n   * @class Class\n   * @memberOf Metal\n   * @memberOf Backbone\n   */\n  var Class = Metal.Class = Backbone.Class = function() {\n    this.initialize.apply(this, arguments);\n  };\n  \n  /**\n   * An overridable method called when objects are instantiated. Does not do\n   * anything by default.\n   *\n   * @public\n   * @abstract\n   * @method initialize\n   */\n  Class.prototype.initialize = _.noop;\n  \n  _.extend(Class, {\n  \n    /**\n     * Creates a new subclass.\n     *\n     * ```js\n     * var MyClass = Class.extend({\n     *   // ...\n     * });\n     *\n     * var myClass = new MyClass();\n     * myClass instanceof MyClass\n     * // true\n     * myClass instanceof Class\n     * // true\n     * ```\n     *\n     * @public\n     * @static\n     * @method extend\n     * @param {Object} [protoProps] - The properties to be added to the prototype.\n     * @param {Object} [staticProps] - The properties to be added to the constructor.\n     */\n    extend(protoProps, staticProps) {\n      var Parent = this;\n      var Child;\n  \n      // The constructor function for the new subclass is either defined by you\n      // (the \"constructor\" property in your `extend` definition), or defaulted\n      // by us to simply call the parent's constructor.\n      if (protoProps && _.has(protoProps, 'constructor')) {\n        Child = wrap(protoProps.constructor, Parent.prototype.constructor);\n      } else {\n        Child = function() { Parent.apply(this, arguments); };\n      }\n  \n      // Add static properties to the constructor function, if supplied.\n      _.extend(Child, Parent);\n      wrapAll(Child, staticProps);\n  \n      // Set the prototype chain to inherit from `parent`, without calling\n      // `parent`'s constructor function.\n      var Surrogate = function() { this.constructor = Child; };\n      Surrogate.prototype = Parent.prototype;\n      Child.prototype = new Surrogate();\n  \n      // Add prototype properties (instance properties) to the subclass,\n      // if supplied.\n      wrapAll(Child.prototype, protoProps);\n  \n      // Set a convenience property in case the parent class is needed later.\n      Child.superclass = Parent;\n  \n      // Set a convenience property in case the parent's prototype is needed\n      // later.\n      Child.__super__ = Parent.prototype;\n  \n      return Child;\n    },\n  \n    /**\n     * Mixes properties onto the class's prototype.\n     *\n     * ```js\n     * var MyMixin = new Mixin({\n     *   alert() {\n     *     console.log('Alert!');\n     *   }\n     * });\n     *\n     * var MyClass = Class.extend({\n     *   initialize() {\n     *     this.alert();\n     *   }\n     * });\n     *\n     * MyClass.mixin(MyMixin);\n     *\n     * new MyClass();\n     * // >> Alert!\n     * ```\n     *\n     * @public\n     * @static\n     * @method mixin\n     * @param {Object} protoProps - The properties to be added to the prototype.\n     * @return {Class} - The class.\n     */\n    mixin(protoProps) {\n      // Add prototype properties (instance properties) to the class, if supplied.\n      wrapAll(this.prototype, protoProps);\n      return this;\n    },\n  \n    /**\n     * Mixes properties onto the class's constructor.\n     *\n     * ```js\n     * var MyMixin = new Mixin({\n     *   alert() {\n     *     console.log('Alert!');\n     *   }\n     * });\n     *\n     * var MyClass = Class.extend(...);\n     *\n     * MyClass.include(MyMixin);\n     *\n     * MyClass.alert();\n     * // >> Alert!\n     * ```\n     *\n     * You can also simply pass a plain javascript object.\n     *\n     * ```js\n     * var MyClass = Class.extend(...);\n     *\n     * MyClass.include({\n     *   alert() {\n     *     console.log('Alert!');\n     *   }\n     * });\n     *\n     * MyClass.alert();\n     * // >> Alert!\n     * ```\n     *\n     * @public\n     * @static\n     * @method mixin\n     * @param {Object} protoProps - The properties to be added to the constructor.\n     * @return {Class} - The class.\n     */\n    include(staticProps) {\n      // Add static properties to the constructor function, if supplied.\n      wrapAll(this, staticProps);\n      return this;\n    }\n  });\n  \n  /**\n   * Allows you to create mixins, whose properties can be added to other classes.\n   *\n   * @public\n   * @class Mixin\n   * @memberOf Metal\n   * @memberOf Backbone\n   * @param {Object} protoProps - The properties to be added to the prototype.\n   */\n  var Mixin = Metal.Mixin = Backbone.Mixin = function(protoProps) {\n    // Add prototype properties (instance properties) to the class, if supplied.\n    _.extend(this, protoProps);\n  };\n  \n  /**\n   * @private\n   * @const {String[]}\n   */\n  var errorProps = [\n    'description', 'fileName', 'lineNumber', 'name', 'message', 'number'\n  ];\n  \n  /**\n   * A subclass of the JavaScript Error object for use in Backbone. Can also add\n   * a url based on the urlRoot.\n   *\n   * ```js\n   * throw new Metal.Error('Oh you\\'ve really done it now...');\n   * // Uncaught Metal.Error: Oh you've really done it now...\n   * //   [stack trace]\n   * ```\n   *\n   * @class Error\n   * @memberOf Metal\n   * @extends Error\n   * @uses Metal.Class\n   */\n  var Err = Metal.Error = Backbone.Error = Class.extend.call(Error, {\n  \n    /**\n     * @property {String} urlRoot - The root url to be used in the error message.\n     */\n    urlRoot: 'http://github.com/thejameskyle/backbone-metal',\n  \n    /**\n     * @public\n     * @constructs Error\n     * @param {String} [message] - A description of the error.\n     * @param {Object} [options] - Settings for the error.\n     * @param {String} [options.message] - A description of the error.\n     * @param {String} [options.url] - The url to visit for more help.\n     */\n    constructor(message, options = {}) {\n      // If options are provided in place of a message, assume message exists on\n      // options.\n      if (_.isObject(message)) {\n        options = message;\n        message = options.message;\n      }\n  \n      // Create a fake error with message in order to capture a stack trace.\n      var error = Error.call(this, message);\n  \n      // Copy over all the error-related properties.\n      _.extend(this, _.pick(error, errorProps), _.pick(options, errorProps));\n  \n      // Adds a `stack` property to the given error object that will yield the\n      // stack trace at the time captureStackTrace was called.\n      // When collecting the stack trace all frames above the topmost call\n      // to this function, including that call, will be left out of the\n      // stack trace.\n      // This is useful because we can hide Metal implementation details\n      // that are not very helpful for the user.\n      this.captureStackTrace();\n  \n      // Add url property to error, if provided.\n      if (options.url) {\n        this.url = this.urlRoot + options.url;\n      }\n    },\n  \n    /**\n     * A safe reference to V8's `Error.captureStackTrace`.\n     *\n     * @public\n     * @method captureStackTrace\n     */\n    captureStackTrace() {\n      // Error.captureStackTrace does not exist in all browsers.\n      if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, Err);\n      }\n    },\n  \n    /**\n     * Formats the error message to display in the console.\n     *\n     * @public\n     * @method toString\n     * @returns {String} - Formatted error message.\n     */\n    toString() {\n      return this.name + ': ' + this.message + (\n        this.url ? ' See: ' + this.url : ''\n      );\n    }\n  });\n  \n  /**\n   * @class Error\n   * @mixes Class\n   */\n  _.extend(Err, Class);\n  \n  /**\n   * Display a deprecation warning with the provided message.\n   *\n   * @public\n   * @method deprecate\n   * @param {String|Object} message - A description of the deprecation.\n   * @param {String} message.prev - The deprecated item.\n   * @param {String} message.next - The replacement for the deprecated item.\n   * @param {String} [message.url] - The url to visit for more help.\n   * @param {Boolean} [test] - An optional boolean. If falsy, the deprecation will be displayed.\n   */\n  var deprecate = Metal.deprecate = Backbone.deprecate = function(message, test) {\n  \n    // Returns if test is provided and is falsy.\n    if (test !== undefined && test) {\n      return;\n    }\n  \n    // If message is provided as an object, format the object into a string.\n    if (_.isObject(message)) {\n      message = deprecate._format(message.prev, message.next, message.url);\n    }\n  \n    // Ensure that message is a string\n    message = message && message.toString();\n  \n    // If deprecation message has not already been warned, send the warning.\n    if (!deprecate._cache[message]) {\n      deprecate._warn('Deprecation warning: ' + message);\n      deprecate._cache[message] = true;\n    }\n  };\n  \n  /**\n   * Format a message for deprecate.\n   *\n   * @private\n   * @method _format\n   * @memberOf deprecate\n   * @param {String} prev - The deprecated item.\n   * @param {String} next - The replacement for the deprecated item.\n   * @param {String} [url] - The url to visit for more help.\n   * @return {Sring} - The formatted message.\n   */\n  deprecate._format = function(prev, next, url) {\n    return (\n      prev + ' is going to be removed in the future. ' +\n      'Please use ' + next + ' instead.' +\n      (url ? ' See: ' + url : '')\n    );\n  };\n  \n  /**\n   * A safe reference to `console.warn` that will fallback to `console.log` or\n   * `_noop` if the `console` object does not exist.\n   *\n   * @private\n   * @method _warn\n   * @memberOf deprecate\n   * @param {*...} - The values to warn in the console.\n   */\n  if (typeof console !== 'undefined') {\n    deprecate._warn = console.warn || console.log;\n  }\n  \n  // If `console.warn` and `console.log` weren't found, just noop.\n  if (!deprecate._warn) {\n    deprecate._warn = _.noop;\n  }\n  \n  /**\n   * An internal cache to avoid sending the same deprecation warning multiple\n   * times.\n   *\n   * @private\n   * @property _cache\n   * @memberOf deprecate\n   */\n  deprecate._cache = {};\n  \n  /**\n   * A `Metal.Mixin` version of `Backbone.Events`.\n   *\n   * @mixin Events\n   * @memberOf Metal\n   * @memberOf Backbone\n   * @extends Metal.Mixin\n   * @mixes Backbone.Events\n   */\n  var Events = Metal.Events = Backbone.Events = new Mixin(Backbone.Events);\n  \n  /**\n   * @class Class\n   * @mixes Events\n   */\n  Class.mixin(Events);\n  \n  /**\n   * Split the event name on the \":\"\n   *\n   * @private\n   * @const {RegExp}\n   */\n  var triggerSplitter = /(^|:)(\\w)/gi;\n  \n  /**\n   * Take the event section (\"section1:section2:section3\") and turn it in to\n   * uppercase name.\n   *\n   * @private\n   * @method getEventName\n   * @param {String} match - The matched substring.\n   * @param {Number} offset - The offset of the matched substring within the total string being examined.\n   * @param {String} eventName - The event name.\n   * @return {String} - The uppercase event name.\n   */\n  function getEventName(match, offset, eventName) {\n    return eventName.toUpperCase();\n  }\n  \n  /**\n   * A set of utility functions to be mixed into any class. Already mixed into\n   * `Metal.Class`.\n   *\n   * @mixin Utils\n   * @memberOf Metal\n   * @memberOf Backbone\n   * @extends Metal.Mixin\n   */\n  var Utils = Metal.Utils = Backbone.Utils = new Mixin({\n  \n    /**\n     * Trigger an event and/or a corresponding method name.\n     *\n     * `this.triggerMethod(\"foo\")` will trigger the \"foo\" event and\n     * call the \"onFoo\" method.\n     *\n     * `this.triggerMethod(\"foo:bar\")` will trigger the \"foo:bar\" event and\n     * call the \"onFooBar\" method.\n     *\n     * ```js\n     * var MyClass = Class.extend({\n     *   initialize() {\n     *     this.on('class:created', function() {\n     *       console.log('Trigger Called!');\n     *     });\n     *\n     *     this.triggerMethod('class:created');\n     *   },\n     *\n     *   onClassCreated() {\n     *     console.log('Method Called!');\n     *   }\n     * });\n     *\n     * new MyClass();\n     * // >> Method Called!\n     * // >> Trigger Called!\n     * ```\n     *\n     * @public\n     * @method triggerMethod\n     * @param {String} event - The name of the event.\n     * @param {*...} args - The arguments to pass to the method and trigger.\n     * @return {*} - The result of the method.\n     */\n    triggerMethod(event, ...args) {\n  \n      // Get the method name from the event name\n      var methodName = 'on' + event.replace(triggerSplitter, getEventName);\n      var method = this[methodName];\n      var result;\n  \n      // call the onMethodName if it exists\n      if (_.isFunction(method)) {\n        // pass all arguments, except the event name\n        result = method.apply(this, args);\n      }\n  \n      // trigger the event, if a trigger method exists\n      if (_.isFunction(this.trigger)) {\n        this.trigger.apply(this, arguments);\n      }\n  \n      return result;\n    },\n  \n    /**\n     * Retrieve an object, function or other value from a target\n     * object or its `options`, with `options` taking precedence.\n     *\n     * ```js\n     * var Person = Class.extend({\n     *   name: 'James Kyle',\n     *\n     *   intialize(options) {\n     *     this.options = options;\n     *     this.greet();\n     *   },\n     *\n     *   greet() {\n     *     var name = this.getOption('name');\n     *     console.log(`Hello, my name is ${name}.`);\n     *   }\n     * });\n     *\n     * new Person();\n     * // >> Hello, my name is James Kyle.\n     * new Person({ name: 'Sam Saccone' });\n     * // >> Hello, my name is Sam Saccone.\n     * ```\n     *\n     * @public\n     * @method getOption\n     * @param {String} name - The name of the option to get.\n     * @returns {*} - The value of the option.\n     */\n    getOption(name) {\n      if (this.options && this.options[name] !== undefined) {\n        return this.options[name];\n      } else {\n        return this[name];\n      }\n    }\n  });\n  \n  /**\n   * @class Class\n   * @mixes Utils\n   */\n  Class.mixin(Utils);\n  \n  _.mixin({\n  \n    /**\n     * Checks if `value` is a Metal Class.\n     *\n     * ```js\n     * _.isClass(Class.extend(...));\n     * // >> true\n     * _.isClass(function() {...});\n     * // >> false\n     * _.isClass({...});\n     * // >> false\n     * _.isClass(new Class());\n     * // >> false\n     * ```\n     * @public\n     * @method isClass\n     * @memberOf _\n     * @param {*} value - The value to check.\n     */\n    isClass: function(value) {\n      return !!value && value.prototype instanceof Class;\n    },\n  \n    /**\n     * Checks if `value` is a Metal Mixin.\n     *\n     * ```js\n     * _.isMixin(new Mixin());\n     * // >> true\n     * _.isMixin({});\n     * // >> false\n     * _.isMixin(function() {...});\n     * // >> false\n     * _.isMixin(new Class());\n     * // >> false\n     * ```\n     *\n     * @public\n     * @method isMixin\n     * @memberOf _\n     * @param {*} value - The value to check.\n     */\n    isMixin: function(value) {\n      return !!value && value instanceof Mixin;\n    }\n  });\n  \n  return Metal;\n});\n"],"sourceRoot":"/source/"}